function [X_optimum,F_optimum,misc] = SC_SAHEL(lb,ub,MaxFcal,ObjFun,varargin)
% Shuffled Complex-Self Adaptive Hybrid Evolution Algorithm Code is
% developed based on the SCE-UA code written by DR. Q. Duan 9/2004 and the 
% SP-UCI algorithm, developed by Dr. Wei Chu, 08/2012
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Developed by Matin Rahnamay Naeini. Last modified on January-2018    %
%                         Email: rahnamam@uci.edu                         %
%                    University of California, Irvine                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          _____  _____      _____         _    _ ______ _                %     
%         / ____|/ ____|    / ____|  /\   | |  | |  ____| |               %     
%        | (___ | |   _____| (___   /  \  | |__| | |__  | |               %     
%         \___ \| |  |______\___ \ / /\ \ |  __  |  __| | |               %     
%         ____) | |____     ____) / ____ \| |  | | |____| |____           %  
%        |_____/ \_____|   |_____/_/    \_\_|  |_|______|______|          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Please reference to:
% Matin Rahnamay Naeini, Tiantian Yang, Mojtaba Sadegh, Amir Aghakouchak,
% Kuo-lin Hsu, Soroosh Sorooshian, Qingyun Duan, and Xiaohui Lei. "Shuffled 
% complex-self adaptive hybrid evolution (SC-SAHEL) optimization
% framework." Environmental Modelling & Software, 104:215 - 235, 2018.
%
%
% Disclaimer
% The Shuffled Complex-Self Adaptive Hybrid EvoLution (SC-SAHEL) 
% optimization toolbox is provided 'as is' without any warranty of any 
% kind, express or implied. While we strive to provide accurate codes for 
% SC-SAHEL toolbox, we cannot guarantee the accuracy of the codes, figures 
% and examples. The results generated by the SC-SAHEL framework can be used
% at your own discretion and risk, and with agreement that you will be 
% solely responsible for errors or omissions of the SC-SAHEL codes, 
% outputs, documents and figures. In no event shall the authors, developers
% or their affiliate institutions be liable to you or any third parties for
% any special, direct, indirect or consequential damages and financial 
% risks of any kind, or any damages whatsoever, resulting from, arising out
% of or in connection with the use of the SC-SAHEL toolbox. 
% The code is subject to change without notice.
%
% References:
% - Duan, Qingyun, Soroosh Sorooshian, and Vijai Gupta. "Effective and 
% efficient global optimization for conceptual rainfall?runoff models." 
% Water resources research 28, no. 4 (1992): 1015-1031.
% - Chu, Wei, Xiaogang Gao, and Soroosh Sorooshian. "A new evolutionary 
% search strategy for global optimization of high-dimensional problems." 
% Information Sciences 181, no. 22 (2011): 4909-4927.
% - Chu, Wei, Xiaogang Gao, and Soroosh Sorooshian. "Improving the shuffled 
% complex evolution scheme for optimization of complex nonlinear 
% hydrological systems: Application to the calibration of the Sacramento 
% soil?moisture accounting model." Water Resources Research 46, no. 9(2010).
%
%% Inputs
% The algorithm requires at least 4 inputs, the lower bound, upper bound,
% Maximum number of function evaluation, ObjFun function handle
%% Outputs
% Outputs include X_optimum, which is the vector of optimum variables,
% F_optimum is the optimum objective function value, misc is a structure
% which store all the information from optimization steps.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Setup the algorithm settings
[opt] = ParamSet(lb,ub,MaxFcal,ObjFun,varargin);
fprintf('Generating initial population ...\n')
% Sample the population
X = opt.SampMethod(opt.PopSize,opt.lb,opt.ub);
% Allocate memory for samples objective function
F = nan(1,opt.PopSize);
% Compute samples fitness (objective function) for all the samples
fc = zeros(opt.PopSize,1);
% Generate the initial population
if opt.Parallel
    ObjFun = opt.ObjFun;
    parfor i = 1:opt.PopSize
        F(i) = ObjFun(X(i,:),opt.Data);
        fc(i) = fc(i)+1;
    end
else
    for i = 1:opt.PopSize
        F(i) = opt.ObjFun(X(i,:),opt.Data);
        fc(i) = fc(i)+1;
    end
end
fprintf('Initial population is ready!\n')
% Set Shuffling Counter
SCC = 1;
% Store number of function call
fcal(SCC) = sum(fc);
%% Evolution
fprintf('Evolve the population ...\n')
% Save current samples
XX(1:opt.PopSize,:) = X;
% Save current samples objective function
FF(1:opt.PopSize,1) = F';
% Assign memory for the selection of evolutionary methods
EA_select(1,:) = repmat((1:opt.EvolNum)',opt.NumOfComplex/opt.EvolNum,1);
% Assign memory for evolutionary methods performance criteria
% All the complexes have same EMP in the beginning
EMP = zeros(1,opt.NumOfComplex);
% All the EAs have same performance in the beginning
EApr(1,:) = ones(1,opt.EvolNum)/opt.EvolNum;
% Start evolution
while fcal(SCC) < opt.MaxFcal
    % Save the best points location and objective function
    [Best_F(SCC),idx] = min(F); Best_X(SCC,:) = X(idx,:); 
    % Sort samples in order of increasing objective function
    [F,idx] = sort(F); X = X(idx,:);
    % Partiotion samples into complexes
    [CX,FX] = PartitionComp(X,F,opt.NumOfComplex);
    % Randomly assign complexes to evolutionary methods
    [EA_select(SCC+1,:),EApr(SCC+1,:)] = EAselection(opt.EvolNum,EA_select(SCC,:),EMP);
    % Evolve complexes independently
    [CX,FX,EMP,fc] = Evol(CX,FX,Best_X(SCC,:),Best_F(SCC),opt.EA,EA_select(SCC+1,:),...
        opt.EvolStep,opt.ObjFun,opt.bh,opt.Data,opt.DimRest,opt.ReSamp,opt.Parallel);
    % shuffle complexes
    X = reshape(CX,opt.PopSize,opt.dim);
    F = reshape(FX,opt.PopSize,1);
    % Save the current samples location and objective function
    XX(SCC*opt.PopSize+1:(SCC+1)*opt.PopSize,:) = X;
    FF(SCC*opt.PopSize+1:(SCC+1)*opt.PopSize,1) = F;
    % Control termination rules and convergence
    fcal(SCC+1) = fcal(SCC) + fc;
    if fcal(SCC+1) > opt.MaxFcal
        disp('Maximum number of function evaluation has been reached!')
        break
    end
    % Calculate the geometric range and check whether it is smaller than
    % threshold
    grng = exp(mean(log((max(X)-min(X))./(opt.ub-opt.lb))));
    if grng < opt.StopSP
        fprintf('The geometric range is smaller than %0.0e!\n',opt.StopSP);
        break
    end
    % Check if the objective function is improved in last 50 itteration
    if SCC > opt.StopStep
        criter_change = abs(Best_F(SCC)-Best_F(SCC-opt.StopStep+1));
        criter_change = 100*criter_change/mean(abs(Best_F(SCC-opt.StopStep+1:SCC)));
        if isnan(criter_change)
            criter_change = 0;
        end
        if criter_change < opt.StopIMP
            fprintf('Improvement in the last %d steps is smaller than %0.2f! SC-SAHEL has converged!\n',[opt.StopStep,opt.StopIMP]);
            break
        end
    end
    % Update the shuffling counter
    SCC = SCC+1;
end
% Save the best points location and objective function value
[Best_F(SCC+1),idx] = min(F); Best_X(SCC+1,:) = X(idx,:);
X_optimum = Best_X(SCC+1,:); F_optimum = Best_F(SCC+1);
% Generate the misc structure
misc.FunCal = fcal;
misc.BestF = Best_F;
misc.BestX = Best_X;
misc.EAselect = EA_select(2:end,:);
misc.EAs = opt.EAs;